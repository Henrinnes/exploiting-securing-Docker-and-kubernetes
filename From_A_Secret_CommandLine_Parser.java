import anbxj.AnBx_Debug;
import anbxj.AnBx_Layers;
import anbxj.Channel_Roles;
import anbxj.Channel_Settings;
import anbxj.Channel_SSLChannelType;
import anbxj.Crypto_Config;

import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

public final class From_A_Secret_CommandLine_Parser {

	// default values - overridden by command line parameters!
	private static Channel_SSLChannelType ct = Channel_SSLChannelType.SSL_NONE;
	private static String usage = "USAGE: java From_A_Secret [-r ROLE_A | ROLE_B] [-t ssl_channeltype] [-verbose] [-silent] [-f configfilename]";
	
	// other values
	private final static AnBx_Layers layer = AnBx_Layers.APPLICATION;
	private static String keypath = null;
	private static String sharepath = null;
	private static String myAlias = null;
	private static Crypto_Config crypto_config = null;
	private static From_A_Secret_Roles role = null;
	private static String configFileName = "";
	private static String protname = "";
	
	public static void Parse(String[] args, String prot) {

		protname = prot;
		configFileName = protname + ".properties";
		AnBx_Debug.setAppname(protname);

		AnBx_Debug.setAPPLICATION(true);
		AnBx_Debug.setPROTOCOL(true);
		// AnBx_Debug.setSESSION(true);
		// AnBx_Debug.setLANGUAGE(true);
		// AnBx_Debug.setENCRYPTION(true);
		// AnBx_Debug.setBUSINESS_LOGIC(true);
		AnBx_Debug.setALL(true); // true only for testing speed
		
		ParseArgs(args);
	
		if (role != null)
			initProtocol();
		else
			terminate("no role or incorrect role specified");
		AnBx_Debug.out(layer, "myAlias: " + myAlias);
	}
	
	private static void ParseArgs(String[] args) {

		int i = 0;
		String arg = null;
		boolean vflag = false;
		
		while (i < args.length && args[i].startsWith("-")) {
			arg = args[i++];

			// check for "wordy" arguments

			if (arg.equals("-verbose")) {
				AnBx_Debug.out(layer, "Verbose mode on");
				vflag = true;
				AnBx_Debug.setALL(vflag);
			}
			if (arg.equals("-silent")) {
				AnBx_Debug.out(layer, "Silent mode on");
				vflag = false;
				AnBx_Debug.setALL(vflag);
			}
			// check for arguments that require params
			if (arg.equals("-f")) {
				if (i < args.length) {
					configFileName = new String(args[i]);
					i++;
				} else
					terminate("config file not specified");
			}
			if (arg.equals("-t")) {
				if (i < args.length) {
					ct = Channel_SSLChannelType.String2ChannelType(args[i]);
					if (ct == Channel_SSLChannelType.SSL_NONE)
						terminate("wrong channel mode specified");
					i++;
				} else
					terminate("channel mode not specified");
			}
			if (arg.equals("-r")) {
				if (i < args.length) {
					for (From_A_Secret_Roles peer : From_A_Secret_Roles.values()) {
						if (args[i].equalsIgnoreCase(peer.toString()))
							role = peer;
					}
					i++;
				} else
					terminate("no role specified");
			}
		}
	}
	
	private static void initProtocol() {

		Map<String, Channel_Settings> cs = new HashMap<String, Channel_Settings>();
		Map<String, String> aliases = new HashMap<String, String>();
		From_A_Secret_Principal From_A_Secret_pr = null;
		AnBx_Debug.setAppname(role.toString());
		initRole(ct, role, cs, aliases);
		AnBx_Debug.out(layer, "myRole: " + role);

		if (myAlias != null && keypath != null && sharepath != null) {
			From_A_Secret_pr = new From_A_Secret_Principal(myAlias, keypath, cs, aliases, crypto_config);
			switch (role) {
			case ROLE_A:
				From_A_Secret_pr.run(new From_A_Secret_ROLE_A(role, protname, sharepath));
				break;
			case ROLE_B:
				From_A_Secret_pr.run(new From_A_Secret_ROLE_B(role, protname, sharepath));
				break;
			
			}
		} else terminate("Unable to initialize " + protname + " Principal");
	}
	
	private static void terminate(String msg) {
		System.err.println("From_A_Secret: " + msg);
		System.err.println(usage);
		System.exit(0);
	}

	public static String getRole() {
		if (role!=null) 
				return role.toString();
		else
				return "role not defined";
	}
		
//	private static String channelName(From_A_Secret_Roles role1, From_A_Secret_Roles role2) {
//		final String CHANNEL_SUFFIX="_channel_";
//		return role1.toString() + CHANNEL_SUFFIX + role2.toString();
//	}

	private static void initRole(Channel_SSLChannelType ct, From_A_Secret_Roles role, Map<String, Channel_Settings> cs, Map<String, String> aliases) {
		
		final String HOST_SUFFIX="_host";
		final String ROLE_SUFFIX="_role";
		final String PORT_SUFFIX="_port";
		final String TYPE_SUFFIX="_type";
		final String CHANNEL_SUFFIX="_channel_";
		
		Properties configFile = new Properties();
		// Read properties file.
		AnBx_Debug.out(layer, "Reading config file: " + configFileName.toString());
		InputStream propertiesStream = From_A_Secret_CommandLine_Parser.class.getResourceAsStream(configFileName);
		if (propertiesStream != null) {
		  try {
			configFile.load(propertiesStream);
			crypto_config = new Crypto_Config (configFile);
		} catch (IOException e) {
			terminate("Error reading config file: " + configFileName.toString());
		}
		} else {
		  // Properties file not found!
			terminate("Config file not found: " + configFileName.toString());
			}
		myAlias = configFile.getProperty(role.toString());
		keypath = configFile.getProperty("keypath");
		sharepath = configFile.getProperty("sharepath");
				
		String ch = new String();

		for (From_A_Secret_Roles peer : From_A_Secret_Roles.values()) {
			if (configFile.getProperty(peer.toString()) != null) {
				AnBx_Debug.out(layer, "Role: " + peer.toString() + " - Property: " + configFile.getProperty(peer.toString()));
				aliases.put(peer.toString(), configFile.getProperty(peer.toString()));
			}
			if (!peer.equals(role)) {
				ch = role.toString() + CHANNEL_SUFFIX + peer.toString(); 
				String host = configFile.getProperty(ch + HOST_SUFFIX);
				if (host != null) {
					int port = 0;
					try {
						port = Integer.parseInt(configFile.getProperty(ch + PORT_SUFFIX));
					} catch (NumberFormatException e) {
						terminate("NumberFormatException at "+ ch + PORT_SUFFIX + ":" + configFile.getProperty(ch + PORT_SUFFIX));
					}
					if (configFile.getProperty(ch + TYPE_SUFFIX)!=null) { 
                            ct = Channel_SSLChannelType.String2ChannelType(configFile.getProperty(ch + TYPE_SUFFIX));
                            if (ct == Channel_SSLChannelType.SSL_NONE) terminate(ch + TYPE_SUFFIX +": wrong channel mode specified");
                        }
                    else
                        terminate(ch + TYPE_SUFFIX + ": channel mode not specified");
                    
					if (configFile.getProperty(ch + ROLE_SUFFIX).equalsIgnoreCase(Channel_Roles.CLIENT.toString())) {
						cs.put(peer.toString(),new Channel_Settings(ct, Channel_Roles.CLIENT, host, port));
					} else if (configFile.getProperty(ch + ROLE_SUFFIX).equalsIgnoreCase(Channel_Roles.SERVER.toString())) {
						cs.put(peer.toString(),new Channel_Settings(ct, Channel_Roles.SERVER, host, port));
					}
					else terminate("Incorrect channel role specified for " + ch + ROLE_SUFFIX + "\n" + "Possible channel roles are " + Channel_Roles.CLIENT.toString() + " or "  + Channel_Roles.SERVER.toString());
				}
			}
		}
	
		try {
			propertiesStream.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}	
